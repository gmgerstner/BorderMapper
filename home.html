<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atlas Fictiva — Border Mapper</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400;600;700&family=JetBrains+Mono:wght@300;400&display=swap" rel="stylesheet">
    <style>
        :root {
            --parchment: #f4f1e8;
            --ink-dark: #1a1613;
            --ink-medium: #3d3731;
            --atlas-blue: #2c5f7f;
            --atlas-red: #8b3a3a;
            --atlas-green: #3a5e3e;
            --gold: #d4af37;
            --shadow: rgba(0, 0, 0, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Cormorant Garamond', serif;
            background: linear-gradient(135deg, #1a1613 0%, #2d2620 100%);
            color: var(--parchment);
            overflow: hidden;
            height: 100vh;
        }

        #root {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .app-header {
            background: linear-gradient(180deg, rgba(26, 22, 19, 0.95) 0%, rgba(45, 38, 32, 0.9) 100%);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--gold);
            padding: 1.5rem 2rem;
            box-shadow: 0 4px 20px var(--shadow);
            z-index: 1000;
            animation: slideDown 0.6s ease-out;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .title-section h1 {
            font-size: 2.5rem;
            font-weight: 700;
            letter-spacing: 0.05em;
            color: var(--gold);
            margin-bottom: 0.25rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .title-section p {
            font-size: 0.95rem;
            font-weight: 300;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: var(--parchment);
            opacity: 0.8;
            font-family: 'JetBrains Mono', monospace;
        }

        .controls {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        button {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1rem;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            border: 2px solid var(--gold);
            background: rgba(212, 175, 55, 0.1);
            color: var(--parchment);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            letter-spacing: 0.05em;
            text-transform: uppercase;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(212, 175, 55, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.5s, height 0.5s;
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button:hover {
            border-color: var(--parchment);
            background: rgba(212, 175, 55, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(212, 175, 55, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button span {
            position: relative;
            z-index: 1;
        }

        .map-container {
            flex: 1;
            position: relative;
            border: 3px solid var(--gold);
            margin: 1.5rem;
            box-shadow: 
                inset 0 0 50px rgba(0, 0, 0, 0.5),
                0 10px 40px rgba(0, 0, 0, 0.6);
            animation: fadeIn 0.8s ease-out 0.3s both;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        #map {
            height: 100%;
            width: 100%;
            background: #1a2332;
        }

        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(26, 22, 19, 0.92);
            backdrop-filter: blur(10px);
            border: 2px solid var(--gold);
            padding: 0.75rem 1rem;
            border-radius: 0;
            min-width: 180px;
            max-width: 220px;
            z-index: 999;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s ease;
        }

        .info-panel.hidden {
            transform: translateX(calc(100% + 20px));
            opacity: 0;
            pointer-events: none;
        }

        .info-panel h3 {
            font-size: 1rem;
            font-weight: 700;
            color: var(--gold);
            margin-bottom: 0.5rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            border-bottom: 1px solid rgba(212, 175, 55, 0.3);
            padding-bottom: 0.35rem;
        }

        .info-panel p {
            font-size: 0.8rem;
            line-height: 1.4;
            color: var(--parchment);
            margin-bottom: 0.35rem;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 300;
        }

        .info-panel strong {
            color: var(--gold);
            font-weight: 600;
        }

        .toggle-instructions {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(26, 22, 19, 0.92);
            backdrop-filter: blur(10px);
            border: 2px solid var(--gold);
            padding: 0.5rem 0.75rem;
            z-index: 1000;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Cormorant Garamond', serif;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--gold);
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .toggle-instructions:hover {
            background: rgba(212, 175, 55, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(212, 175, 55, 0.3);
        }

        .toggle-instructions.panel-visible {
            opacity: 0;
            pointer-events: none;
        }

        /* Leaflet customization */
        .leaflet-control-container {
            filter: sepia(20%) brightness(0.9);
            position: relative !important;
            z-index: 2000 !important;
        }

        .leaflet-control-container * {
            z-index: 2001 !important;
        }

        .leaflet-top,
        .leaflet-bottom {
            z-index: 2002 !important;
        }

        .leaflet-draw-toolbar,
        .leaflet-draw-actions {
            z-index: 2003 !important;
        }

        .leaflet-draw-toolbar a {
            background-color: rgba(26, 22, 19, 0.9) !important;
            border: 1px solid var(--gold) !important;
            position: relative !important;
            z-index: 2004 !important;
        }

        .leaflet-draw-toolbar a:hover {
            background-color: rgba(212, 175, 55, 0.2) !important;
        }

        .leaflet-draw-actions a {
            z-index: 2004 !important;
        }

        .leaflet-popup-content-wrapper {
            background: rgba(26, 22, 19, 0.95);
            color: var(--parchment);
            border: 2px solid var(--gold);
            font-family: 'Cormorant Garamond', serif;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
            border-radius: 0;
        }

        .leaflet-popup-tip {
            background: rgba(26, 22, 19, 0.95);
            border: 1px solid var(--gold);
        }

        .leaflet-popup-content {
            margin: 0.75rem 1rem;
        }

        /* File input styling */
        input[type="file"] {
            display: none;
        }

        .file-label {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1rem;
            font-weight: 600;
            padding: 0.75rem 1.5rem;
            border: 2px solid var(--atlas-blue);
            background: rgba(44, 95, 127, 0.1);
            color: var(--parchment);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            letter-spacing: 0.05em;
            text-transform: uppercase;
            display: inline-block;
            position: relative;
            overflow: hidden;
        }

        .file-label:hover {
            border-color: var(--parchment);
            background: rgba(44, 95, 127, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(44, 95, 127, 0.3);
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(26, 22, 19, 0.98);
            border: 3px solid var(--gold);
            padding: 2rem 3rem;
            z-index: 10000;
            font-size: 1.2rem;
            color: var(--parchment);
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.8);
            animation: popIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes popIn {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        /* Decorative corner elements */
        .corner-decoration {
            position: fixed;
            width: 80px;
            height: 80px;
            border: 2px solid var(--gold);
            opacity: 0.3;
            pointer-events: none;
            z-index: 100;
        }

        .corner-decoration.top-left {
            top: 10px;
            left: 10px;
            border-right: none;
            border-bottom: none;
        }

        .corner-decoration.top-right {
            top: 10px;
            right: 10px;
            border-left: none;
            border-bottom: none;
        }

        .corner-decoration.bottom-left {
            bottom: 10px;
            left: 10px;
            border-right: none;
            border-top: none;
        }

        .corner-decoration.bottom-right {
            bottom: 10px;
            right: 10px;
            border-left: none;
            border-top: none;
        }

        /* Territory naming modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10001;
            animation: fadeInOverlay 0.3s ease;
        }

        @keyframes fadeInOverlay {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: linear-gradient(180deg, rgba(26, 22, 19, 0.98) 0%, rgba(35, 30, 25, 0.98) 100%);
            border: 3px solid var(--gold);
            padding: 2rem 2.5rem;
            min-width: 400px;
            max-width: 500px;
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.8),
                inset 0 1px 0 rgba(212, 175, 55, 0.2);
            animation: modalSlideIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes modalSlideIn {
            from {
                transform: translateY(-30px) scale(0.9);
                opacity: 0;
            }
            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        .modal-content h2 {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--gold);
            margin-bottom: 1.5rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            text-align: center;
            border-bottom: 1px solid rgba(212, 175, 55, 0.3);
            padding-bottom: 1rem;
        }

        .form-group {
            margin-bottom: 1.25rem;
        }

        .form-group label {
            display: block;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--gold);
            margin-bottom: 0.5rem;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .form-group input[type="text"],
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 0.75rem 1rem;
            background: rgba(244, 241, 232, 0.05);
            border: 2px solid rgba(212, 175, 55, 0.4);
            color: var(--parchment);
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.1rem;
            transition: all 0.3s ease;
        }

        .form-group input[type="text"]:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--gold);
            background: rgba(244, 241, 232, 0.1);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.2);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .form-group select {
            cursor: pointer;
        }

        .form-group select option {
            background: #1a1613;
            color: var(--parchment);
        }

        .color-preview {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid var(--gold);
            margin-left: 0.5rem;
            vertical-align: middle;
        }

        .modal-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(212, 175, 55, 0.2);
        }

        .modal-buttons button {
            min-width: 120px;
        }

        .btn-cancel {
            border-color: var(--atlas-red) !important;
            background: rgba(139, 58, 58, 0.1) !important;
        }

        .btn-cancel:hover {
            background: rgba(139, 58, 58, 0.2) !important;
            border-color: var(--parchment) !important;
        }

        .btn-save {
            border-color: var(--atlas-green) !important;
            background: rgba(58, 94, 62, 0.1) !important;
        }

        .btn-save:hover {
            background: rgba(58, 94, 62, 0.2) !important;
            border-color: var(--parchment) !important;
        }

        /* Territory list panel */
        .territory-list {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(26, 22, 19, 0.92);
            backdrop-filter: blur(10px);
            border: 2px solid var(--gold);
            padding: 0.75rem 1rem;
            max-width: 280px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 999;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.4s ease;
        }

        .territory-list.hidden {
            transform: translateX(calc(-100% - 20px));
            opacity: 0;
            pointer-events: none;
        }

        .territory-list h3 {
            font-size: 0.9rem;
            font-weight: 700;
            color: var(--gold);
            margin-bottom: 0.5rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            border-bottom: 1px solid rgba(212, 175, 55, 0.3);
            padding-bottom: 0.35rem;
        }

        .territory-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0;
            border-bottom: 1px solid rgba(212, 175, 55, 0.1);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .territory-item:hover {
            background: rgba(212, 175, 55, 0.1);
            padding-left: 0.5rem;
        }

        .territory-item:last-child {
            border-bottom: none;
        }

        .territory-color {
            width: 12px;
            height: 12px;
            border: 1px solid var(--gold);
            flex-shrink: 0;
        }

        .territory-name {
            font-size: 0.85rem;
            color: var(--parchment);
            font-family: 'JetBrains Mono', monospace;
            font-weight: 300;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .toggle-territories {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(26, 22, 19, 0.92);
            backdrop-filter: blur(10px);
            border: 2px solid var(--gold);
            padding: 0.5rem 0.75rem;
            z-index: 1000;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Cormorant Garamond', serif;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--gold);
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .toggle-territories:hover {
            background: rgba(212, 175, 55, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(212, 175, 55, 0.3);
        }

        .toggle-territories.panel-visible {
            opacity: 0;
            pointer-events: none;
        }

        /* Custom scrollbar for territory list */
        .territory-list::-webkit-scrollbar {
            width: 6px;
        }

        .territory-list::-webkit-scrollbar-track {
            background: rgba(212, 175, 55, 0.1);
        }

        .territory-list::-webkit-scrollbar-thumb {
            background: var(--gold);
            border-radius: 3px;
        }

        /* Map labels for territory names */
        .territory-label {
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            font-family: 'Cormorant Garamond', serif !important;
            font-size: 14px !important;
            font-weight: 600 !important;
            color: var(--parchment) !important;
            text-shadow: 
                1px 1px 2px rgba(0,0,0,0.9),
                -1px -1px 2px rgba(0,0,0,0.9),
                1px -1px 2px rgba(0,0,0,0.9),
                -1px 1px 2px rgba(0,0,0,0.9) !important;
            white-space: nowrap !important;
        }

        .territory-label::before {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <div class="corner-decoration top-left"></div>
    <div class="corner-decoration top-right"></div>
    <div class="corner-decoration bottom-left"></div>
    <div class="corner-decoration bottom-right"></div>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // Color palette for territories
        const TERRITORY_COLORS = [
            { name: 'Royal Gold', value: '#d4af37' },
            { name: 'Crimson Empire', value: '#8b3a3a' },
            { name: 'Forest Realm', value: '#3a5e3e' },
            { name: 'Azure Kingdom', value: '#2c5f7f' },
            { name: 'Violet Dominion', value: '#6b4c7a' },
            { name: 'Amber Duchy', value: '#b87333' },
            { name: 'Jade Province', value: '#4a7c59' },
            { name: 'Slate Confederation', value: '#5a6672' }
        ];

        // Territory naming modal component
        function TerritoryModal({ isOpen, onClose, onSave, initialData, isEditing }) {
            const [name, setName] = useState('');
            const [description, setDescription] = useState('');
            const [color, setColor] = useState(TERRITORY_COLORS[0].value);
            const inputRef = useRef(null);

            useEffect(() => {
                if (isOpen) {
                    setName(initialData?.name || '');
                    setDescription(initialData?.description || '');
                    setColor(initialData?.color || TERRITORY_COLORS[Math.floor(Math.random() * TERRITORY_COLORS.length)].value);
                    
                    // Focus input after a short delay
                    setTimeout(() => {
                        inputRef.current?.focus();
                        inputRef.current?.select();
                    }, 100);
                }
            }, [isOpen, initialData]);

            const handleSubmit = (e) => {
                e.preventDefault();
                onSave({
                    name: name.trim() || 'Unnamed Territory',
                    description: description.trim(),
                    color
                });
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Escape') {
                    onClose();
                }
            };

            if (!isOpen) return null;

            return (
                <div className="modal-overlay" onClick={onClose} onKeyDown={handleKeyDown}>
                    <div className="modal-content" onClick={e => e.stopPropagation()}>
                        <h2>{isEditing ? 'Edit Territory' : 'Name Your Territory'}</h2>
                        <form onSubmit={handleSubmit}>
                            <div className="form-group">
                                <label htmlFor="territory-name">Territory Name</label>
                                <input
                                    ref={inputRef}
                                    type="text"
                                    id="territory-name"
                                    value={name}
                                    onChange={e => setName(e.target.value)}
                                    placeholder="e.g., Kingdom of Northwind"
                                    maxLength={50}
                                />
                            </div>
                            <div className="form-group">
                                <label htmlFor="territory-desc">Description (Optional)</label>
                                <textarea
                                    id="territory-desc"
                                    value={description}
                                    onChange={e => setDescription(e.target.value)}
                                    placeholder="A brief description of this territory..."
                                    maxLength={200}
                                />
                            </div>
                            <div className="form-group">
                                <label htmlFor="territory-color">
                                    Border Color
                                    <span 
                                        className="color-preview" 
                                        style={{ backgroundColor: color }}
                                    />
                                </label>
                                <select
                                    id="territory-color"
                                    value={color}
                                    onChange={e => setColor(e.target.value)}
                                >
                                    {TERRITORY_COLORS.map(c => (
                                        <option key={c.value} value={c.value}>
                                            {c.name}
                                        </option>
                                    ))}
                                </select>
                            </div>
                            <div className="modal-buttons">
                                <button type="button" className="btn-cancel" onClick={onClose}>
                                    <span>Cancel</span>
                                </button>
                                <button type="submit" className="btn-save">
                                    <span>{isEditing ? 'Update' : 'Create'}</span>
                                </button>
                            </div>
                        </form>
                    </div>
                </div>
            );
        }

        // Territory list component
        function TerritoryList({ territories, onSelect, onClose, isVisible }) {
            if (territories.length === 0) {
                return null;
            }

            return (
                <div className={`territory-list ${!isVisible ? 'hidden' : ''}`}>
                    <h3>
                        Territories ({territories.length})
                        <button 
                            onClick={onClose}
                            style={{
                                float: 'right',
                                background: 'none',
                                border: 'none',
                                color: 'var(--gold)',
                                cursor: 'pointer',
                                fontSize: '1.2rem',
                                padding: '0',
                                lineHeight: '1',
                                marginTop: '-0.15rem'
                            }}
                        >
                            ×
                        </button>
                    </h3>
                    {territories.map((t, index) => (
                        <div 
                            key={t.id || index} 
                            className="territory-item"
                            onClick={() => onSelect(t)}
                            title={t.description || 'Click to zoom'}
                        >
                            <span 
                                className="territory-color" 
                                style={{ backgroundColor: t.color }}
                            />
                            <span className="territory-name">{t.name}</span>
                        </div>
                    ))}
                </div>
            );
        }

        function BorderMapper() {
            const mapRef = useRef(null);
            const mapInstanceRef = useRef(null);
            const drawnItemsRef = useRef(null);
            const labelsLayerRef = useRef(null);
            const pendingLayerRef = useRef(null);
            
            const [borderCount, setBorderCount] = useState(0);
            const [notification, setNotification] = useState('');
            const [showInstructions, setShowInstructions] = useState(false);
            const [showTerritoryList, setShowTerritoryList] = useState(true);
            const [territories, setTerritories] = useState([]);
            
            // Modal state
            const [modalOpen, setModalOpen] = useState(false);
            const [editingTerritory, setEditingTerritory] = useState(null);
            const [isEditMode, setIsEditMode] = useState(false);

            // Update territories list from drawn items
            const updateTerritoriesList = useCallback(() => {
                if (!drawnItemsRef.current) return;
                
                const items = [];
                drawnItemsRef.current.eachLayer(layer => {
                    const props = layer.feature?.properties || {};
                    items.push({
                        id: L.stamp(layer),
                        name: props.name || 'Unnamed Territory',
                        description: props.description || '',
                        color: props.color || '#d4af37',
                        layer: layer
                    });
                });
                setTerritories(items);
                setBorderCount(items.length);
            }, []);

            // Update map labels
            const updateLabels = useCallback(() => {
                if (!labelsLayerRef.current || !drawnItemsRef.current) return;
                
                // Clear existing labels
                labelsLayerRef.current.clearLayers();
                
                // Add label for each territory
                drawnItemsRef.current.eachLayer(layer => {
                    const props = layer.feature?.properties || {};
                    const name = props.name;
                    
                    if (name && layer.getBounds) {
                        const center = layer.getBounds().getCenter();
                        const label = L.marker(center, {
                            icon: L.divIcon({
                                className: 'territory-label',
                                html: name,
                                iconSize: null
                            }),
                            interactive: false
                        });
                        labelsLayerRef.current.addLayer(label);
                    }
                });
            }, []);

            // Initialize a layer with feature properties
            const initializeLayerFeature = (layer, props = {}) => {
                layer.feature = layer.feature || { type: 'Feature', properties: {} };
                layer.feature.properties = {
                    ...layer.feature.properties,
                    ...props
                };
            };

            // Apply styling to a layer
            const applyLayerStyle = (layer, color) => {
                if (layer.setStyle) {
                    layer.setStyle({
                        color: color,
                        weight: 3,
                        opacity: 0.8,
                        fillOpacity: 0.3
                    });
                }
            };

            // Create popup content for a territory
            const createPopupContent = (props) => {
                return `
                    <div style="min-width: 150px;">
                        <h4 style="margin: 0 0 0.5rem 0; color: var(--gold); font-size: 1.2rem; border-bottom: 1px solid rgba(212,175,55,0.3); padding-bottom: 0.5rem;">
                            ${props.name || 'Unnamed Territory'}
                        </h4>
                        ${props.description ? `<p style="margin: 0 0 0.5rem 0; font-size: 0.9rem; opacity: 0.9;">${props.description}</p>` : ''}
                        <p style="margin: 0; font-size: 0.8rem; opacity: 0.7; font-family: 'JetBrains Mono', monospace;">
                            Click to edit
                        </p>
                    </div>
                `;
            };

            useEffect(() => {
                if (!mapInstanceRef.current) {
                    // Initialize map
                    const map = L.map(mapRef.current, {
                        crs: L.CRS.EPSG4326,
                        maxBounds: [[-90, -180], [90, 180]],
                        maxBoundsViscosity: 1.0
                    }).setView([0, 0], 2);

                    // Add tile layer
                    L.tileLayer('https://tiles.gmgdigitaltechnologies.com/arkonus/images/{z}/{y}/{x}.jpg', {
                        maxZoom: 7,
                        attribution: '&copy; <a href="https://gmgdigitaltechnologies.com">GMG DT</a>',
                        bounds: [[-90, -180], [90, 180]],
                        noWrap: false
                    }).addTo(map);

                    // Initialize feature groups
                    const drawnItems = new L.FeatureGroup();
                    map.addLayer(drawnItems);
                    drawnItemsRef.current = drawnItems;

                    const labelsLayer = new L.FeatureGroup();
                    map.addLayer(labelsLayer);
                    labelsLayerRef.current = labelsLayer;

                    // Add draw control
                    const drawControl = new L.Control.Draw({
                        position: 'topleft',
                        draw: {
                            polygon: {
                                shapeOptions: {
                                    color: '#d4af37',
                                    weight: 3,
                                    opacity: 0.8,
                                    fillOpacity: 0.3
                                },
                                allowIntersection: false,
                                showArea: true
                            },
                            polyline: {
                                shapeOptions: {
                                    color: '#d4af37',
                                    weight: 4,
                                    opacity: 0.9
                                }
                            },
                            rectangle: {
                                shapeOptions: {
                                    color: '#d4af37',
                                    weight: 3,
                                    opacity: 0.8,
                                    fillOpacity: 0.3
                                }
                            },
                            circle: false,
                            circlemarker: false,
                            marker: true
                        },
                        edit: {
                            featureGroup: drawnItems,
                            remove: true
                        }
                    });
                    map.addControl(drawControl);

                    // Handle shape creation - open modal
                    map.on(L.Draw.Event.CREATED, (event) => {
                        const layer = event.layer;
                        pendingLayerRef.current = layer;
                        setIsEditMode(false);
                        setEditingTerritory(null);
                        setModalOpen(true);
                    });

                    // Handle deletion
                    map.on(L.Draw.Event.DELETED, () => {
                        updateTerritoriesList();
                        updateLabels();
                    });

                    // Handle edit completion
                    map.on(L.Draw.Event.EDITED, () => {
                        updateLabels();
                    });

                    mapInstanceRef.current = map;
                }

                return () => {
                    if (mapInstanceRef.current) {
                        mapInstanceRef.current.remove();
                        mapInstanceRef.current = null;
                    }
                };
            }, [updateTerritoriesList, updateLabels]);

            const showNotification = (message) => {
                setNotification(message);
                setTimeout(() => setNotification(''), 2000);
            };

            // Handle modal save for new territory
            const handleModalSave = (data) => {
                if (isEditMode && editingTerritory) {
                    // Editing existing territory
                    const layer = editingTerritory.layer;
                    initializeLayerFeature(layer, data);
                    applyLayerStyle(layer, data.color);
                    layer.setPopupContent(createPopupContent(data));
                    
                    showNotification(`"${data.name}" updated!`);
                } else if (pendingLayerRef.current) {
                    // Creating new territory
                    const layer = pendingLayerRef.current;
                    initializeLayerFeature(layer, data);
                    applyLayerStyle(layer, data.color);
                    
                    // Add popup
                    layer.bindPopup(createPopupContent(data));
                    
                    // Add click handler to open edit modal
                    layer.on('click', () => {
                        const props = layer.feature?.properties || {};
                        setEditingTerritory({
                            layer,
                            name: props.name,
                            description: props.description,
                            color: props.color
                        });
                        setIsEditMode(true);
                        setModalOpen(true);
                    });
                    
                    // Add to map
                    drawnItemsRef.current.addLayer(layer);
                    pendingLayerRef.current = null;
                    
                    showNotification(`"${data.name}" created!`);
                }
                
                setModalOpen(false);
                setEditingTerritory(null);
                updateTerritoriesList();
                updateLabels();
            };

            // Handle modal close (cancel)
            const handleModalClose = () => {
                setModalOpen(false);
                pendingLayerRef.current = null;
                setEditingTerritory(null);
            };

            // Handle territory selection from list
            const handleTerritorySelect = (territory) => {
                const layer = territory.layer;
                if (layer && layer.getBounds) {
                    mapInstanceRef.current.fitBounds(layer.getBounds(), {
                        padding: [50, 50],
                        maxZoom: 5
                    });
                    layer.openPopup();
                }
            };

            const handleSave = () => {
                if (!drawnItemsRef.current || drawnItemsRef.current.getLayers().length === 0) {
                    showNotification('No borders to save!');
                    return;
                }

                const data = drawnItemsRef.current.toGeoJSON();
                const dataStr = JSON.stringify(data, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `atlas-fictiva-${Date.now()}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                showNotification('Territories saved successfully!');
            };

            const handleLoad = (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        // Clear existing layers
                        drawnItemsRef.current.clearLayers();
                        labelsLayerRef.current.clearLayers();
                        
                        // Add loaded layers
                        L.geoJSON(data, {
                            style: (feature) => ({
                                color: feature.properties?.color || '#d4af37',
                                weight: 3,
                                opacity: 0.8,
                                fillOpacity: 0.3
                            }),
                            onEachFeature: (feature, layer) => {
                                // Preserve feature data
                                layer.feature = feature;
                                
                                const props = feature.properties || {};
                                
                                // Add popup
                                layer.bindPopup(createPopupContent(props));
                                
                                // Add click handler to open edit modal
                                layer.on('click', () => {
                                    setEditingTerritory({
                                        layer,
                                        name: props.name,
                                        description: props.description,
                                        color: props.color
                                    });
                                    setIsEditMode(true);
                                    setModalOpen(true);
                                });
                                
                                drawnItemsRef.current.addLayer(layer);
                            }
                        });

                        updateTerritoriesList();
                        updateLabels();
                        showNotification('Territories loaded successfully!');
                    } catch (error) {
                        showNotification('Error loading file!');
                        console.error('Error loading borders:', error);
                    }
                };
                reader.readAsText(file);
                
                event.target.value = '';
            };

            const handleClear = () => {
                if (drawnItemsRef.current && window.confirm('Clear all territories? This cannot be undone.')) {
                    drawnItemsRef.current.clearLayers();
                    labelsLayerRef.current.clearLayers();
                    setTerritories([]);
                    setBorderCount(0);
                    showNotification('All territories cleared');
                }
            };

            return (
                <>
                    <div className="app-header">
                        <div className="header-content">
                            <div className="title-section">
                                <h1>Atlas Fictiva</h1>
                                <p>Cartographic Border Mapper</p>
                            </div>
                            <div className="controls">
                                <button onClick={handleSave}>
                                    <span>Save Borders</span>
                                </button>
                                <label htmlFor="file-upload" className="file-label">
                                    Load Borders
                                </label>
                                <input
                                    id="file-upload"
                                    type="file"
                                    accept=".json"
                                    onChange={handleLoad}
                                />
                                <button onClick={handleClear} style={{ borderColor: '#8b3a3a' }}>
                                    <span>Clear All</span>
                                </button>
                            </div>
                        </div>
                    </div>

                    <div className="map-container">
                        <div ref={mapRef} id="map"></div>
                        
                        {/* Instructions toggle */}
                        <button 
                            className={`toggle-instructions ${showInstructions ? 'panel-visible' : ''}`}
                            onClick={() => setShowInstructions(true)}
                        >
                            Show Instructions
                        </button>
                        
                        {/* Instructions panel */}
                        <div className={`info-panel ${!showInstructions ? 'hidden' : ''}`}>
                            <h3>
                                Instructions
                                <button 
                                    onClick={() => setShowInstructions(false)}
                                    style={{
                                        float: 'right',
                                        background: 'none',
                                        border: 'none',
                                        color: 'var(--gold)',
                                        cursor: 'pointer',
                                        fontSize: '1.2rem',
                                        padding: '0',
                                        lineHeight: '1',
                                        marginTop: '-0.15rem'
                                    }}
                                >
                                    ×
                                </button>
                            </h3>
                            <p><strong>Draw:</strong> Use toolbar to create polygons, lines, or markers</p>
                            <p><strong>Name:</strong> A dialog will appear to name each territory</p>
                            <p><strong>Edit:</strong> Click any territory to rename or change color</p>
                            <p><strong>Delete:</strong> Use trash icon in toolbar</p>
                            <p><strong>Territories:</strong> {borderCount} created</p>
                        </div>

                        {/* Territory list toggle */}
                        {territories.length > 0 && (
                            <button 
                                className={`toggle-territories ${showTerritoryList ? 'panel-visible' : ''}`}
                                onClick={() => setShowTerritoryList(true)}
                            >
                                Show Territories
                            </button>
                        )}
                        
                        {/* Territory list */}
                        <TerritoryList 
                            territories={territories}
                            onSelect={handleTerritorySelect}
                            onClose={() => setShowTerritoryList(false)}
                            isVisible={showTerritoryList}
                        />
                    </div>

                    {/* Territory naming modal */}
                    <TerritoryModal
                        isOpen={modalOpen}
                        onClose={handleModalClose}
                        onSave={handleModalSave}
                        initialData={editingTerritory}
                        isEditing={isEditMode}
                    />

                    {notification && (
                        <div className="notification">
                            {notification}
                        </div>
                    )}
                </>
            );
        }

        ReactDOM.render(<BorderMapper />, document.getElementById('root'));
    </script>
</body>
</html>